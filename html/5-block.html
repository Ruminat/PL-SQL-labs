<!DOCTYPE html><html lang="ru"><head><title>PL/SQL Лабы. Блок 5</title><meta charset="UTF-8"><link rel="icon" href="./../img/icons/database.png"><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous"><link rel="stylesheet" href="./../css/main.css"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"></head><body><nav id="menu"><a class="element" id="menu-switch"><div class="icon-part"><i class="fas fa-bars"></i></div><div class="text-part"></div></a><a class="element" href="../index.html"><div class="icon-part"><i class="fas fa-home"></i></div><div class="text-part">На главную</div></a><a class="element link" href="https://github.com/Ruminat/PL-SQL-labs"><div class="icon-part"><i class="fab fa-github"></i></div><div class="text-part">GitHub</div></a><a class="element" href="#lab-18"><div class="icon-part">18.</div><div class="text-part">лабораторная</div></a><a class="element sub" id="contents-task-18-1" href="#task-18-1"><div class="icon-part">1.</div><div class="text-part">задание</div></a><a class="element sub" id="contents-task-18-2" href="#task-18-2"><div class="icon-part">2.</div><div class="text-part">задание</div></a><a class="element sub" id="contents-task-18-3" href="#task-18-3"><div class="icon-part">3.</div><div class="text-part">задание</div></a><a class="element" href="#lab-19"><div class="icon-part">19.</div><div class="text-part">лабораторная</div></a><a class="element sub" id="contents-task-19-1" href="#task-19-1"><div class="icon-part">1.</div><div class="text-part">задание</div></a><a class="element sub" id="contents-task-19-2" href="#task-19-2"><div class="icon-part">2.</div><div class="text-part">задание</div></a><a class="element sub" id="contents-task-19-3" href="#task-19-3"><div class="icon-part">3.</div><div class="text-part">задание</div></a><a class="element sub" id="contents-task-19-4" href="#task-19-4"><div class="icon-part">4.</div><div class="text-part">задание</div></a><a class="element sub" id="contents-task-19-5" href="#task-19-5"><div class="icon-part">5.</div><div class="text-part">задание</div></a><a class="element" href="#lab-20"><div class="icon-part">20.</div><div class="text-part">лабораторная</div></a><a class="element sub" id="contents-task-20-1" href="#task-20-1"><div class="icon-part">1.</div><div class="text-part">задание</div></a><a class="element sub" id="contents-task-20-2" href="#task-20-2"><div class="icon-part">2.</div><div class="text-part">задание</div></a><a class="element sub" id="contents-task-20-3" href="#task-20-3"><div class="icon-part">3.</div><div class="text-part">задание</div></a><a class="element sub" id="contents-task-20-4" href="#task-20-4"><div class="icon-part">4.</div><div class="text-part">задание</div></a><a class="element" href="#lab-21"><div class="icon-part">21.</div><div class="text-part">лабораторная</div></a><a class="element sub" id="contents-task-21-1" href="#task-21-1"><div class="icon-part">1.</div><div class="text-part">задание</div></a><a class="element sub" id="contents-task-21-2" href="#task-21-2"><div class="icon-part">2.</div><div class="text-part">задание</div></a><a class="element sub" id="contents-task-21-3" href="#task-21-3"><div class="icon-part">3.</div><div class="text-part">задание</div></a></nav><div id="main"><div class="labs"><div class="header"><h2>Пятый Блок</h2></div><div class="lab" id="lab-18"><a name="#lab-18"><h4>Практическое занятие 18. Создание Compound триггеров, DDL-триггеров и триггеров на события в базе данных</h4></a><div class="task" id="task-18-1"><p class="task-text" name="task-18-1"><b>Задание 1.</b> С помощью триггеров необходимо реализовать следующее бизнес-правило: зарплата любого сотрудника не может быть меньше минимальной зарплаты установленной для его должности/категории. При повышении минимальной зарплаты для той или иной должности/категории в таблице <code class='language-plsql'>Jobs</code> необходимо просмотреть данные по всем сотрудникам этой должности в таблице <code class='language-plsql'>Employees</code> и повысить до необходимой величины зарплату всем тем сотрудникам, чья текущая зарплата оказалась ниже нового минимального оклада. Создайте триггер, связанный с таблицей <code class='language-plsql'>Jobs</code>, который будет использовать пакетную хранимую процедуру.</p><ul><li>В пакет <code class="language-plsql">emp_pkg</code> добавьте хранимую процедуру <code class="language-plsql">set_salary</code>.<ul> <li><code class="language-plsql">set_salary</code> должна обновлять зарплаты сотрудников. </li><li>Процедура должна принимать на вход 2 параметра:<ul><li>ID должности</li><li>и новую минимальную величину зарплаты для этой должности. </li></ul></li><li>Процедура должна обновлять зарплату всех сотрудников соответствующей должности так, чтобы она была не меньше новой минимальной.</li></ul></li><li>Создайте строчный триггер <code class="language-plsql">upd_minsalary_trg</code>, связанный с таблицей <code class="language-plsql">Jobs</code>, который будет вызывать процедуру <code class="language-plsql">emp_pkg.set_salary</code>, когда минимальный уровень зарплаты для той или иной должности будет изменяться.</li><li>Протестируйте работу триггера. Для этого просмотрите информацию о всех сотрудниках, работающих в должности <code class="language-plsql">'IT_PROG'</code>, зафиксируйте их текущие зарплаты. Увеличьте минимальный оклад для этой должности на $1000. Что должно было произойти, и что произошло на самом деле? </li><p>При тестировании работы триггера, вы столкнетесь с проблемой «mutating table» — чтение изменяющейся таблицы. (В таблице <code class="language-plsql">Employees</code> есть свой триггер <code class="language-plsql">check_salary</code>, который будет читать таблицу <code class="language-plsql">Jobs</code>). Эту ошибку надо исправить.</p></ul><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE PACKAGE emp_pkg AUTHID CURRENT_USER IS
  -- ... ... ...
  PROCEDURE set_salary (jobID Employees.Job_ID%TYPE, newSalary Employees.Salary%TYPE);
END emp_pkg;
/</code></pre><pre><code class="language-output">Package created.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE PACKAGE BODY emp_pkg IS

  -- ... ... ...

  PROCEDURE set_salary (jobID Employees.Job_ID%TYPE, newSalary Employees.Salary%TYPE) IS
  BEGIN
    UPDATE Employees
    SET Salary = GREATEST(Salary, newSalary)
    WHERE Job_ID = jobID;
  END;

  -- ... ... ...

END emp_pkg;
/</code></pre><pre><code class="language-output">Package body created.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE TRIGGER upd_minsalary_trg
AFTER UPDATE OF Min_Salary ON Jobs
FOR EACH ROW
WHEN (OLD.Min_Salary != NEW.Min_Salary)
BEGIN
  emp_pkg.set_salary(:NEW.Job_ID, :NEW.Min_Salary);
END;
/</code></pre><pre><code class="language-output">Trigger created.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">SELECT Last_Name, First_Name, Salary, Job_ID
FROM Employees
WHERE Job_ID = 'IT_PROG';</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>LAST_NAME</th><th>FIRST_NAME</th><th>SALARY</th><th>JOB_ID</th></tr></thead><tbody><tr><td>Hunold</td><td>Alexander</td><td>9000</td><td>IT_PROG</td></tr><tr><td>Ernst</td><td>Bruce</td><td>6000</td><td>IT_PROG</td></tr><tr><td>Austin</td><td>David</td><td>4800</td><td>IT_PROG</td></tr><tr><td>Pataballa</td><td>Valli</td><td>4800</td><td>IT_PROG</td></tr><tr><td>Lorentz</td><td>Diana</td><td>4200</td><td>IT_PROG</td></tr></tbody></table></row><pre class="line-numbers undefined"><code class="language-plsql">UPDATE Jobs
SET Min_Salary = Min_Salary + 1000
WHERE Job_ID = 'IT_PROG';</code></pre><pre class="error-code"><code class="language-output">[42000][4091] ORA-04091: таблица RUMINAT.JOBS изменяется, триггер/функция может не заметить это
ORA-06512: на  "RUMINAT.CHECK_SALARY", line 6
ORA-06512: на  "RUMINAT.CHECK_SALARY_TRG", line 2
ORA-04088: ошибка во время выполнения триггера 'RUMINAT.CHECK_SALARY_TRG'
ORA-06512: на  "RUMINAT.EMP_PKG", line 128
ORA-06512: на  "RUMINAT.UPD_MINSALARY_TRG", line 2
ORA-04088: ошибка во время выполнения триггера 'RUMINAT.UPD_MINSALARY_TRG'
</code></pre><p>Мы должны были обновить поле <code class="language-plsql">Salary</code> у работников с <code class="language-plsql">Job_ID = 'IT_PROG'</code>, однако вместо этого получили ошибку.</p></div><div class="task" id="task-18-2"><p class="task-text" name="task-18-2"><b>Задание 2.</b> Чтобы обойти проблему «mutating table» вам потребуется создать временную копию таблицы <code class='language-plsql'>Jobs</code> изменить процедуру <code class='language-plsql'>check_salary</code> так, чтобы она обращалась к этой временной таблице, вместо чтения оригинальной таблицы <code class='language-plsql'>Jobs</code>.</p><ul><li>Создайте новый пакет <code class="language-plsql">jobs_pkg</code> со следующей спецификацией:<pre class="line-numbers undefined"><code class="language-plsql">PROCEDURE initialize;
FUNCTION  get_minSalary (jobID VARCHAR2) RETURN NUMBER;
FUNCTION  get_maxSalary (jobID VARCHAR2) RETURN NUMBER;
PROCEDURE set_minSalary (jobID VARCHAR2, min_salary NUMBER);
PROCEDURE set_maxSalary (jobID VARCHAR2, max_salary NUMBER);</code></pre></li><li>Создайте тело пакета <code class="language-plsql">jobs_pkg</code>:<ul> <li>В теле пакета опишите тип индексированной таблицы <code class="language-plsql">jobs_tab_type</code>, записи в этой таблице должны быть <code class="language-plsql">Jobs%ROWTYPE</code>, а проиндексированы они должны быть с помощью строковых переменных типа <code class="language-plsql">Jobs.Job_ID%TYPE</code>. </li><li>Создайте локальную переменную в пакете <code class="language-plsql">jobsTab</code> типа <code class="language-plsql">jobs_tab_type</code>.</li><li>В теле процедуры <code class="language-plsql">initialize</code> в цикле заполните индексированную таблицу на основе таблицы <code class="language-plsql">Jobs</code>. Значения из столбца <code class="language-plsql">Jobs.Job_ID</code> используйте в качестве индексного значения.</li><li>Опишите функцию <code class="language-plsql">get_minSalary</code>: функция по индексу находит в таблице запись и возвращает значение столбца <code class="language-plsql">Min_Salary</code>.</li><li>Опишите функцию <code class="language-plsql">get_maxSalary</code>: функция по индексу находит в таблице запись и возвращает значение столбца <code class="language-plsql">Max_Salary</code>.</li><li>Опишите процедуры <code class="language-plsql">set_minSalary</code> и <code class="language-plsql">set_maxSalary</code>, которые будут обновлять соответствующие столбцы в индексированной таблице пакета <code class="language-plsql">jobsTab</code>.</li></ul></li><li>Измените описание хранимой процедуры <code class="language-plsql">check_salary</code> (которую вы создавали в упражнении 17.1) следующим образом:<ul> <li>Закомментируйте выборку минимального и максимального значения из таблицы <code class="language-plsql">Jobs</code>.</li><li>Заполните локальные переменные <code class="language-plsql">minSal</code> и <code class="language-plsql">maxSal</code> с помощью функций <code class="language-plsql">jobs_pkg.get_minSalary</code> и <code class="language-plsql">jobs_pkg.get_maxSalary</code> соответственно.</li></ul></li><li>Создайте statement триггер <code class="language-plsql">BEFORE INSERT OR UPDATE</code> для таблицы <code class="language-plsql">Jobs</code> с именем <code class="language-plsql">init_jobspkg_trg</code>. В теле триггера вызовите на исполнение хранимую процедуру <code class="language-plsql">jobs_pkg.initialize</code>, чтобы заполнить локальную индексированную таблицу в пакете до того, как начнется модификация данных.</li><li>Протестируйте работу нового кода:<ul> <li>Просмотрите информацию о программистах и их зарплатах.</li><li>Увеличьте минимально возможную зарплату для программистов (<code class="language-plsql">'IT_PROG'</code>) в таблице <code class="language-plsql">Jobs</code> на $1000.</li><li>Просмотрите информацию о программистах заново. Найдите и перечислите тех сотрудников, зарплата которых изменилась.</li></ul></li></ul><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE PROCEDURE
  check_salary (jobID Employees.Job_ID%TYPE, sal Employees.Salary%TYPE) IS
  minSal Jobs.Min_Salary%TYPE := jobs_pkg.get_minSalary(jobID);
  maxSal Jobs.Max_Salary%TYPE := jobs_pkg.get_maxSalary(jobID);
BEGIN
  -- SELECT Min_Salary, Max_Salary
  -- INTO   minSal,     maxSal
  -- FROM Jobs
  -- WHERE Job_ID = jobID;
 
  IF sal NOT BETWEEN minSal AND maxSal THEN
    RAISE_APPLICATION_ERROR(
      -20001,
        'Invalid salary '|| sal ||' for this job. Salaries must be between '
      || minSal ||' and '|| maxSal
    );
  END IF;
END check_salary;
/</code></pre><pre><code class="language-output">Procedure created.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE PACKAGE jobs_pkg IS
  PROCEDURE initialize;
  FUNCTION  get_minSalary (jobID VARCHAR2) RETURN NUMBER;
  FUNCTION  get_maxSalary (jobID VARCHAR2) RETURN NUMBER;
  PROCEDURE set_minSalary (jobID VARCHAR2, min_salary NUMBER);
  PROCEDURE set_maxSalary (jobID VARCHAR2, max_salary NUMBER);
END jobs_pkg;
/</code></pre><pre><code class="language-output">Package created.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE PACKAGE BODY jobs_pkg IS
  TYPE jobs_tab_type IS TABLE OF Jobs%ROWTYPE INDEX BY Jobs.Job_ID%TYPE;
  jobsTab jobs_tab_type;

  PROCEDURE initialize IS
  BEGIN
    FOR job IN (SELECT * FROM Jobs) LOOP
      jobsTab(job.Job_ID) := job;
    END LOOP;
  END;
  
  FUNCTION  get_minSalary (jobID VARCHAR2) RETURN NUMBER IS
  BEGIN
    RETURN jobsTab(jobID).Min_Salary;
  END;
  
  FUNCTION  get_maxSalary (jobID VARCHAR2) RETURN NUMBER IS
  BEGIN
    RETURN jobsTab(jobID).Max_Salary;
  END;
  
  PROCEDURE set_minSalary (jobID VARCHAR2, min_salary NUMBER) IS
  BEGIN
    jobsTab(jobID).Min_Salary := min_salary;
  END;
  
  PROCEDURE set_maxSalary (jobID VARCHAR2, max_salary NUMBER) IS
  BEGIN
    jobsTab(jobID).Max_Salary := max_salary;
  END;

END jobs_pkg;
/</code></pre><pre><code class="language-output">Package body created.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE TRIGGER init_jobspkg_trg
BEFORE INSERT OR UPDATE ON Jobs
BEGIN
  jobs_pkg.initialize;
END;
/</code></pre><pre><code class="language-output">Trigger created.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">SELECT * FROM Jobs WHERE Job_ID = 'IT_PROG';</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>JOB_ID</th><th>JOB_TITLE</th><th>MIN_SALARY</th><th>MAX_SALARY</th></tr></thead><tbody><tr><td>IT_PROG</td><td>Programmer</td><td>4000</td><td>10000</td></tr></tbody></table></row><pre class="line-numbers undefined"><code class="language-plsql">SELECT Last_Name, First_Name, Salary, Job_ID
FROM Employees
WHERE Job_ID = 'IT_PROG';</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>LAST_NAME</th><th>FIRST_NAME</th><th>SALARY</th><th>JOB_ID</th></tr></thead><tbody><tr><td>Hunold</td><td>Alexander</td><td>9000</td><td>IT_PROG</td></tr><tr><td>Ernst</td><td>Bruce</td><td>6000</td><td>IT_PROG</td></tr><tr><td>Austin</td><td>David</td><td>4800</td><td>IT_PROG</td></tr><tr><td>Pataballa</td><td>Valli</td><td>4800</td><td>IT_PROG</td></tr><tr><td>Lorentz</td><td>Diana</td><td>4200</td><td>IT_PROG</td></tr></tbody></table></row><pre class="line-numbers undefined"><code class="language-plsql">UPDATE Jobs
SET Min_Salary = Min_Salary + 1000
WHERE Job_ID = 'IT_PROG';</code></pre><pre><code class="language-output">1 row updated.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">SELECT * FROM Jobs WHERE Job_ID = 'IT_PROG';</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>JOB_ID</th><th>JOB_TITLE</th><th>MIN_SALARY</th><th>MAX_SALARY</th></tr></thead><tbody><tr><td>IT_PROG</td><td>Programmer</td><td><em class="correct">5000</em></td><td>10000</td></tr></tbody></table></row><pre class="line-numbers undefined"><code class="language-plsql">SELECT Last_Name, First_Name, Salary, Job_ID
FROM Employees
WHERE Job_ID = 'IT_PROG';</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>LAST_NAME</th><th>FIRST_NAME</th><th>SALARY</th><th>JOB_ID</th></tr></thead><tbody><tr><td>Hunold</td><td>Alexander</td><td>9000</td><td>IT_PROG</td></tr><tr><td>Ernst</td><td>Bruce</td><td>6000</td><td>IT_PROG</td></tr><tr><td>Austin</td><td>David</td><td><em class="correct">5000</em></td><td>IT_PROG</td></tr><tr><td>Pataballa</td><td>Valli</td><td><em class="correct">5000</em></td><td>IT_PROG</td></tr><tr><td>Lorentz</td><td>Diana</td><td><em class="correct">5000</em></td><td>IT_PROG</td></tr></tbody></table></row></div><div class="task" id="task-18-3"><p class="task-text" name="task-18-3"><b>Задание 3.</b> Протестируйте работу триггеров при добавлении нового сотрудника:</p><ul><li>Прервите сеанс работы с БД, а затем подключитесь заново.</li><li>С помощью процедуры <code class="language-plsql">emp_pkg.add_employee</code> добавьте нового сотрудника со следующими параметрами <ul><li><code class="language-plsql">('Steven', 'Morse', 'SMORSE', sal =&gt; 6500)</code></li></ul>Что произойдет?</li><li>Для исправления ситуации создайте <code class="language-plsql">BEFORE INSERT OR UPDATE</code> триггер <code class="language-plsql">employee_initJobs_trg</code> на таблицу <code class="language-plsql">Employees</code>, в теле которого вызывайте на исполнение процедуру <code class="language-plsql">jobs_pkg.initialize</code>.</li><li>Еще раз протестируйте работу триггеров и попытайтесь добавить <code class="language-plsql">'Steven Morse'</code>. Убедитесь, что информация о новом сотруднике успешно добавлена в таблицу.</li></ul><pre class="line-numbers undefined"><code class="language-plsql">EXECUTE emp_pkg.add_employee('Steven', 'Morse', 'SMORSE', sal => 6500);</code></pre><pre class="error-code"><code class="language-output">[02000][1403] ORA-01403: данные не найдены
ORA-01403: данные не найдены
ORA-06512: на  "RUMINAT.JOBS_PKG", line 14
ORA-06512: на  "RUMINAT.CHECK_SALARY", line 3
ORA-06512: на  "RUMINAT.CHECK_SALARY_TRG", line 2
ORA-04088: ошибка во время выполнения триггера 'RUMINAT.CHECK_SALARY_TRG'
ORA-06512: на  "RUMINAT.EMP_PKG", line 34
ORA-06512: на  line 2
</code></pre><p>Мы получили ошибку, так как таблица <code class="language-plsql">jobs_pkg.jobsTab</code> на данный момент не заполнена.</p><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE TRIGGER employee_initJobs_trg
BEFORE INSERT OR UPDATE ON Employees
BEGIN
  jobs_pkg.initialize;
END;
/</code></pre><pre><code class="language-output">Trigger created.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">EXECUTE emp_pkg.add_employee('Steven', 'Morse', 'SMORSE', sal => 6500);

SELECT Employee_ID, Last_Name, First_Name, Email, Job_ID, Salary, Department_ID
FROM Employees WHERE Last_Name = 'Morse';</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>EMPLOYEE_ID</th><th>LAST_NAME</th><th>FIRST_NAME</th><th>EMAIL</th><th>JOB_ID</th><th>SALARY</th><th>DEPARTMENT_ID</th></tr></thead><tbody><tr><td>245</td><td>Morse</td><td>Steven</td><td>SMORSE</td><td>SA_REP</td><td>6500</td><td>30</td></tr></tbody></table></row></div></div><div class="lab" id="lab-19"><a name="#lab-19"><h4>Практическое занятие 19. Использование компилятора PL/SQL</h4></a><div class="task" id="task-19-1"><p class="task-text" name="task-19-1"><b>Задание 1.</b> Запустите скрипт с именем <code>lab_10_01.sql</code>. Создайте и выполните запрос для осуществления выборки из словаря <code class='language-plsql'>USER_PLSQL_OBJECT_SETTINGS</code> следующей информации о параметрах инициализации, влияющих на компиляцию кода:</p><ul><li>Имя объекта.</li><li>Тип объекта.</li><li>Был ли объект <code class="language-plsql">'compiled for debugging'</code>.</li><li>Режим компиляции объекта.</li><li>Уровень оптимизации компиляции.</li></ul><p>Зафиксируйте результат. Обратите внимание на информацию об объекте <code class="language-plsql">add_job_history</code>.</p></div><p>Скрипт <code>lab_10_01.sql</code>:</p><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE
PROCEDURE add_job_history(
  p_emp_id        job_history.employee_id%TYPE
, p_start_date    job_history.start_date%TYPE
, p_end_date      job_history.end_date%TYPE
, p_job_id        job_history.job_id%TYPE
, p_department_id job_history.department_id%TYPE)
IS
BEGIN
  INSERT INTO job_history(employee_id, start_date, end_date, job_id, department_id)
  VALUES(p_emp_id, p_start_date, p_end_date, p_job_id, p_department_id);
END add_job_history;
/</code></pre><pre><code class="language-output">Procedure created.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">SELECT Name, Type, PLSQL_Debug, PLSQL_Code_Type, PLSQL_Optimize_Level
FROM USER_PLSQL_OBJECT_SETTINGS;</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>NAME</th><th>TYPE</th><th>PLSQL_DEBUG</th><th>PLSQL_CODE_TYPE</th><th>PLSQL_OPTIMIZE_LEVEL</th></tr></thead><tbody><tr><td>ADD_EMPLOYEE</td><td>PROCEDURE</td><td>FALSE</td><td>INTERPRETED</td><td>2</td></tr><tr><td><em class="correct">ADD_JOB_HISTORY</em></td><td><em class="correct">PROCEDURE</em></td><td><em class="correct">FALSE</em></td><td><em class="correct">INTERPRETED</em></td><td><em class="correct">2</em></td></tr><tr><td>CHECK_SALARY</td><td>PROCEDURE</td><td>FALSE</td><td>INTERPRETED</td><td>2</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr><td>VALID_DEPTID</td><td>FUNCTION</td><td>FALSE</td><td>INTERPRETED</td><td>2</td></tr><tr><td>WEB_EMPLOYEE_REPORT</td><td>PROCEDURE</td><td>FALSE</td><td>INTERPRETED</td><td>2</td></tr></tbody></table></row><div class="task" id="task-19-2"><p class="task-text" name="task-19-2"><b>Задание 2.</b> Измените значение параметра <code class='language-plsql'>plsql_code_type</code> для текущей сессии и скомпилируйте объект <code class='language-plsql'>add_job_history</code>.</p><ul><li>Выполните команду <code class="language-plsql">ALTER SESSION</code> для разрешения <code>native compilation</code>.</li><li>Перекомпилируйте объект <code class="language-plsql">add_job_history</code>.</li><li>Выполните запрос из задачи 19.1 ещё раз. Зафиксируйте результат. Отметьте, что изменилось.</li><li>Верните обратно прежний режим компиляции.</li></ul><pre class="line-numbers undefined"><code class="language-plsql">ALTER SESSION SET PLSQL_CODE_TYPE = 'NATIVE';
ALTER PROCEDURE add_job_history COMPILE;</code></pre><pre><code class="language-output">Session altered.
Procedure altered.</code></pre><pre class="line-numbers undefined"><code class="language-plsql">SELECT Name, Type, PLSQL_Debug, PLSQL_Code_Type, PLSQL_Optimize_Level
FROM USER_PLSQL_OBJECT_SETTINGS;</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>NAME</th><th>TYPE</th><th>PLSQL_DEBUG</th><th>PLSQL_CODE_TYPE</th><th>PLSQL_OPTIMIZE_LEVEL</th></tr></thead><tbody><tr><td>ADD_EMPLOYEE</td><td>PROCEDURE</td><td>FALSE</td><td>INTERPRETED</td><td>2</td></tr><tr><td>ADD_JOB_HISTORY</td><td>PROCEDURE</td><td>FALSE</td><td><em class="correct">NATIVE</em></td><td>2</td></tr><tr><td>CHECK_SALARY</td><td>PROCEDURE</td><td>FALSE</td><td>INTERPRETED</td><td>2</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td></tr><tr><td>VALID_DEPTID</td><td>FUNCTION</td><td>FALSE</td><td>INTERPRETED</td><td>2</td></tr><tr><td>WEB_EMPLOYEE_REPORT</td><td>PROCEDURE</td><td>FALSE</td><td>INTERPRETED</td><td>2</td></tr></tbody></table></row><pre class="line-numbers undefined"><code class="language-plsql">ALTER SESSION SET PLSQL_CODE_TYPE = 'INTERPRETED';
ALTER PROCEDURE add_job_history COMPILE;</code></pre><pre><code class="language-output">Session altered.
Procedure altered.

</code></pre></div><div class="task" id="task-19-3"><p class="task-text" name="task-19-3"><b>Задание 3.</b> С помощью <code>Tools -> Preference -> Database -> PL/SQL Compiler</code> отключите все категории <code>compiler warnings</code>.</p><ul><li>Отредактируйте, просмотрите и выполните скрипт <code>lab_10_04.sql</code> для создания процедуры <code class="language-plsql">unreachable_code</code>. Перекомпилируйте процедуру после создания.</li><li>Удалось ли вам получить какие-то сообщения об ошибках или предупреждения на вкладке <code>Compiler — Log</code>?</li></ul><pre class="line-numbers undefined"><code class="language-plsql">ALTER SESSION SET PLSQL_WARNINGS = 'disable:all';</code></pre><pre><code class="language-output">Session altered.
</code></pre><p>Скрипт <code>lab_10_04.sql</code>:</p><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE PROCEDURE unreachable_code AS
  c_x CONSTANT BOOLEAN := TRUE;
BEGIN
  IF c_x THEN
    DBMS_OUTPUT.PUT_LINE('TRUE');
  ELSE
    DBMS_OUTPUT.PUT_LINE('FALSE');
  END IF;
END unreachable_code;
/</code></pre><pre><code class="language-output">Procedure created.
</code></pre><p>Сообщений об ошибках или предупреждений не было.</p></div><div class="task" id="task-19-4"><p class="task-text" name="task-19-4"><b>Задание 4.</b> С помощью <code>Tools -> Preference -> PL/SQL Compiler Options</code> включите отображение всех предупреждений компилятора.</p><ul><li>Перекомпилируйте процедуру <code class='language-plsql'>unreachable_code</code>. </li><li>Что отобразилось на вкладке <code>Compiler — Log?</code> (Вы так же можете воспользоваться словарем <code class='language-plsql'>USER_ERRORS</code>).</li></ul><pre class="line-numbers undefined"><code class="language-plsql">ALTER SESSION SET PLSQL_WARNINGS = 'enable:all';</code></pre><pre><code class="language-output">Session altered.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE PROCEDURE unreachable_code AS
  c_x CONSTANT BOOLEAN := TRUE;
BEGIN
  IF c_x THEN
    DBMS_OUTPUT.PUT_LINE('TRUE');
  ELSE
    DBMS_OUTPUT.PUT_LINE('FALSE');
  END IF;
END unreachable_code;
/</code></pre><pre class="error-code"><code class="language-output">1:1:PLW-05018: в блоке UNREACHABLE_CODE опущена необязательная фраза AUTHID; используется значение по умолчанию DEFINER
7:5:PLW-06002: Недоступный код
</code></pre></div><div class="task" id="task-19-5"><p class="task-text" name="task-19-5"><b>Задание 5.</b> Создайте скрипт с именем <code class='language-plsql'>warning_msgs</code>, в котором используется <code class='language-plsql'>EXECUTE</code> в сочетании с процедурами из пакетов <code class='language-plsql'>DBMS_OUTPUT</code> и <code class='language-plsql'>DBMS_WARNING</code> для идентификации категорий следующих сообщений: <code>5050</code>, <code>6075</code>, <code>7100</code>.</p></div></div><div class="lab" id="lab-20"><a name="#lab-20"><h4>Практическое занятие 20. Обслуживание кода PL/SQL</h4></a><div class="task" id="task-20-1"><p class="task-text" name="task-20-1"><b>Задание 1.</b> Просмотрите и выполните скрипт <code>lab_11_01.sql</code>. В результате выполнения скрипта будет установлен флаг для отображения <code>debugging</code> и <code>trace</code> информации. Скрипт так же создаст пакет <code class='language-plsql'>my_pkg</code> и процедуру <code class='language-plsql'>circle_area</code>.</p><pre class="line-numbers undefined"><code class="language-plsql">ALTER SESSION SET PLSQL_CCFLAGS = 'my_debug:FALSE, my_tracing:FALSE';
CREATE OR REPLACE PACKAGE my_pkg AS
  SUBTYPE my_real IS
    $IF DBMS_DB_VERSION.VERSION < 10 $THEN NUMBER; -- check database version
      $ELSE                                BINARY_DOUBLE;
    $END
  my_pi my_real; my_e my_real;
END my_pkg;
/
CREATE OR REPLACE PACKAGE BODY my_pkg AS
BEGIN 
  $IF DBMS_DB_VERSION.VERSION < 10 $THEN
       my_pi := 3.14016408289008292431940027343666863227;
       my_e  := 2.71828182845904523536028747135266249775;
  $ELSE
       my_pi := 3.14016408289008292431940027343666863227d;
       my_e  := 2.71828182845904523536028747135266249775d;
  $END
END my_pkg;
/

CREATE OR REPLACE PROCEDURE circle_area(radius my_pkg.my_real) IS
  my_area my_pkg.my_real;
  my_datatype VARCHAR2(30);
BEGIN
  my_area := my_pkg.my_pi * radius;
  DBMS_OUTPUT.PUT_LINE('Radius: ' || TO_CHAR(radius) 
                       || ' Area: ' || TO_CHAR(my_area) );

  $IF $$my_debug $THEN -- if my_debug is TRUE, run some debugging code
    SELECT DATA_TYPE INTO my_datatype FROM USER_ARGUMENTS 
       WHERE OBJECT_NAME = 'CIRCLE_AREA' AND ARGUMENT_NAME = 'RADIUS';
     DBMS_OUTPUT.PUT_LINE('Datatype of the RADIUS argument is: ' || my_datatype);
  $END
END;
/
</code></pre><pre><code class="language-output">Session altered.
Package created.
Package body created.
Procedure created.
</code></pre></div><div class="task" id="task-20-2"><p class="task-text" name="task-20-2"><b>Задание 2.</b> С помощью подпрограммы <code class='language-plsql'>DBMS_PREPROCESSOR</code> отобразите текст из файла <code>lab_11_01.sql</code> в том виде, который он примет после выполнения директив условной компиляции.</p><pre class="line-numbers undefined"><code class="language-plsql">DECLARE
  PROCEDURE printSource(
     sourceType   VARCHAR2
   , sourceName   VARCHAR2
   , sourceSchema VARCHAR2 := USER
  ) IS
    lines DBMS_PREPROCESSOR.SOURCE_LINES_T;
  BEGIN
    lines := DBMS_PREPROCESSOR.GET_POST_PROCESSED_SOURCE(sourceType, sourceSchema, sourceName);
    FOR i IN 1..lines.COUNT LOOP
      DBMS_OUTPUT.PUT(lines(i));
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('');
  END;
BEGIN
  printSource('package',       'my_pkg');
  printSource('package body',  'my_pkg');
  printSource('procedure',     'circle_area');
END;
/</code></pre><pre class="line-numbers undefined"><code class="language-plsql">PACKAGE my_pkg AS
  SUBTYPE my_real IS
    
                                     BINARY_DOUBLE;

  my_pi my_real;
my_e my_real;
END my_pkg;
PACKAGE BODY my_pkg AS
BEGIN
  



       my_pi := 3.14016408289008292431940027343666863227d;
       my_e  := 2.71828182845904523536028747135266249775d;
  
END my_pkg;
PROCEDURE circle_area(radius my_pkg.my_real) IS
  my_area my_pkg.my_real;
my_datatype VARCHAR2(30);
BEGIN
  my_area := my_pkg.my_pi * radius;
DBMS_OUTPUT.PUT_LINE('Radius: ' || TO_CHAR(radius)
                       || ' Area: ' || TO_CHAR(my_area) );





END;

</code></pre></div><div class="task" id="task-20-3"><p class="task-text" name="task-20-3"><b>Задание 3.</b> Создайте PL/SQL скрипт, который использует <code class='language-plsql'>DBMS_DB_VERSION</code> константу. Скрипт определяет версию Oracle.</p><ul><li>Если версия меньше или равна 10.1, необходимо выдать сообщение:<pre><code class="language-output">Unsupported database release</code></pre></li><li>В ином случае — показать сообщение:<pre><code class="language-output">Release {используемые версия СУБД и номер релиза} is supported
</code></pre></li></ul><pre class="line-numbers undefined"><code class="language-plsql">BEGIN
  IF DBMS_DB_VERSION.VER_LE_10_1 THEN
    DBMS_OUTPUT.PUT_LINE('Unsupported database release');
  ELSE
    DBMS_OUTPUT.PUT_LINE(
         'Release '
      || DBMS_DB_VERSION.VERSION ||'.'|| DBMS_DB_VERSION.RELEASE
      || ' is supported'
    );
  END IF;
END;
/</code></pre><pre><code class="language-output">Release 18.0 is supported

</code></pre></div><div class="task" id="task-20-4"><p class="task-text" name="task-20-4"><b>Задание 4.</b> Откройте скрипт <code>lab_11_04.sql</code>. В нем предполагается использование предустановленной процедуры <code class='language-plsql'>create_wrapped</code> для динамического создания и обработки (шифрования) пакета. Отредактируйте скрипт следующим образом:</p><ul><li>Добавьте в используемый анонимный блок исполняемую секцию, в которой:<ul><li>Сгенерируйте текст для создания спецификации пакета с помощью процедуры <code class='language-plsql'>generate_spec</code>, установив значение параметра <code class='language-plsql'>pkgname</code> равным <code class='language-plsql'>'EMP_ACTIONS'</code>. Сохраните его в соответствующей переменной.</li><li>Создайте и зашифруйте (<code>wrap</code>) спецификацию пакета.</li><li>Сгенерируйте текст для создания тела пакета с помощью процедуры <code class='language-plsql'>generate_body</code>. Сохраните его в соответствующей переменной.</li><li>Создайте и зашифруйте (<code>wrap</code>) тело пакета.</li></ul></li><li>Сохраните и выполните скрипт.</li><li>Вызовите процедуру <code class='language-plsql'>emp_actions.raise_salary</code> с параметрами <code class='language-plsql'>(120, 100)</code>. Проверьте результат; </li><li>С помощью словаря <code class='language-plsql'>USER_SOURCE</code> проверьте, что исполняемый код скрыт.</li></ul></div><pre class="line-numbers undefined"><code class="language-plsql">SELECT Employee_ID, Last_Name, Salary
FROM Employees
WHERE Employee_ID = 120;</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>EMPLOYEE_ID</th><th>LAST_NAME</th><th>SALARY</th></tr></thead><tbody><tr><td>120</td><td>Weiss</td><td>8000</td></tr></tbody></table></row><pre class="line-numbers undefined"><code class="language-plsql">DECLARE
-- the package_text variable contains the text to create the package spec and body
  package_text VARCHAR2(32767);
  FUNCTION generate_spec (pkgname VARCHAR2) RETURN VARCHAR2 AS
  BEGIN
     RETURN 'CREATE PACKAGE ' || pkgname || ' AS
       PROCEDURE raise_salary (emp_id NUMBER, amount NUMBER);
       PROCEDURE fire_employee (emp_id NUMBER);
       END ' || pkgname || ';';
  END generate_spec;
  
  FUNCTION generate_body (pkgname VARCHAR2) RETURN VARCHAR2 AS
  BEGIN
     RETURN 'CREATE PACKAGE BODY ' || pkgname || ' AS

     PROCEDURE raise_salary (emp_id NUMBER, amount NUMBER) IS
       BEGIN
         UPDATE employees SET salary = salary + amount WHERE employee_id = emp_id;
       END raise_salary;
     PROCEDURE fire_employee (emp_id NUMBER) IS
       BEGIN
         DELETE FROM employees WHERE employee_id = emp_id;
       END fire_employee;
     END ' || pkgname || ';';
  END generate_body;
BEGIN
  package_text := generate_spec('EMP_ACTIONS');
  DBMS_DDL.CREATE_WRAPPED(package_text);
  package_text := generate_body('EMP_ACTIONS');
  DBMS_DDL.CREATE_WRAPPED(package_text);
END;
/
BEGIN
  emp_actions.raise_salary(120, 100);
END;
/</code></pre><pre><code class="language-output">PL/SQL procedure successfully completed.
PL/SQL procedure successfully completed.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">SELECT Employee_ID, Last_Name, Salary
FROM Employees
WHERE Employee_ID = 120;</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>EMPLOYEE_ID</th><th>LAST_NAME</th><th>SALARY</th></tr></thead><tbody><tr><td>120</td><td>Weiss</td><td><em class="correct">8100</em></td></tr></tbody></table></row><pre class="line-numbers undefined"><code class="language-plsql">SELECT Name, Text
FROM USER_SOURCE
WHERE Name = 'EMP_ACTIONS';</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>NAME</th><th>TYPE</th><th>TEXT</th></tr></thead><tbody><tr><td>EMP_ACTIONS</td><td>PACKAGE</td><td>"PACKAGE EMP_ACTIONS wrapped <em class="correct">a000000 369...</em></td></tr><tr><td>EMP_ACTIONS</td><td>PACKAGE BODY</td><td>"PACKAGE BODY EMP_ACTIONS wrapped <em class="correct">a000000 369...</em></td></tr></tbody></table></row></div><div class="lab" id="lab-21"><a name="#lab-21"><h4>Практическое занятие 21. Обслуживание зависимостей</h4></a><div class="task" id="task-21-1"><p class="task-text" name="task-21-1"><b>Задание 1.</b> Проанализируйте зависимости между объектами в следующем сценарии:</p><p>Хранимая процедура <code class="language-plsql">my_proc</code> вызывает внутри себя на исполнение другую хранимую процедуру <code class="language-plsql">my_proc_pack</code>, размещенную в пакете. Скажется ли изменение реализации и перекомпиляция процедуры <code class="language-plsql">my_proc_pack</code> (без изменения ее объявления в спецификации пакета) на статус процедуры <code class="language-plsql">my_proc</code>. Будет ли она помечена как <code>INVALID</code>?</p><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE PACKAGE testPackage IS
  PROCEDURE my_proc_pack;
END testPackage;
/
CREATE OR REPLACE PACKAGE BODY testPackage IS
  PROCEDURE my_proc_pack IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('I say! I''m testPackage.my_proc_pack!');
  END;
END testPackage;
/

CREATE OR REPLACE
PROCEDURE my_proc IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello there, I''m my_proc!');
  DBMS_OUTPUT.PUT_LINE('I want to call the testPackage.my_proc_pack.');
  testPackage.my_proc_pack;
END;
/</code></pre><pre><code class="language-output">Package created.
Package body created.
Procedure created.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">SELECT Object_Name, Object_Type, Status
FROM USER_OBJECTS
WHERE LOWER(Object_Name) = 'my_proc';</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>OBJECT_NAME</th><th>OBJECT_TYPE</th><th>STATUS</th></tr></thead><tbody><tr><td>MY_PROC</td><td>PROCEDURE</td><td>VALID</td></tr></tbody></table></row><p>Изменим код процедуры <code class="language-plsql">testPackage.my_proc_pack</code> и перекомпилируем её.</p><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE PACKAGE testPackage IS
  PROCEDURE my_proc_pack;
END testPackage;
/
CREATE OR REPLACE PACKAGE BODY testPackage IS
  PROCEDURE my_proc_pack IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('I say! I''m testPackage.my_proc_pack!');
    DBMS_OUTPUT.PUT_LINE('I''m a completely different procedure now!');
  END;
END testPackage;
/</code></pre><pre><code class="language-output">Package created.
Package body created.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">SELECT Object_Name, Object_Type, Status
FROM USER_OBJECTS
WHERE LOWER(Object_Name) = 'my_proc';</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>OBJECT_NAME</th><th>OBJECT_TYPE</th><th>STATUS</th></tr></thead><tbody><tr><td>MY_PROC</td><td>PROCEDURE</td><td>VALID</td></tr></tbody></table></row><p>Как можно заметить, процедура <code class="language-plsql">my_proc</code> не получила статус <code>INVALID</code>.</p></div><div class="task" id="task-21-2"><p class="task-text" name="task-21-2"><b>Задание 2.</b> Создайте древовидную структуру, отражающую все зависимости между объектами на примере процедуры <code class='language-plsql'>add_employee</code> и функции <code class='language-plsql'>valid_deptid</code>.</p><ul><li>Просмотрите и выполните скрипт <code>utldtree.sql</code> из папки курса.</li><li>Выполните процедуру <code class='language-plsql'>deptree_fill</code> для объекта <code class='language-plsql'>add_employee</code>.</li><li>С помощью представления <code class='language-plsql'>ideptree</code> просмотрите результат.</li><li>Выполните процедуру <code class='language-plsql'>deptree_fill</code> для объекта <code class='language-plsql'>valid_deptid</code>.</li><li>С помощью представления <code class='language-plsql'>ideptree</code> просмотрите результат.</li><li>Проанализируйте код процедуры <code class='language-plsql'>deptree_fill</code>. Какие системные ресурсы она опрашивает.</li></ul><p>Скрипт <code>utldtree.sql</code>:</p><pre class="line-numbers undefined"><code class="language-plsql">Rem 
Rem $Header: utldtree.sql,v 1.2 1992/10/26 16:24:44 RKOOI Stab $ 
Rem 
Rem  Copyright (c) 1991 by Oracle Corporation 
Rem    NAME
Rem      deptree.sql - Show objects recursively dependent on given object
Rem    DESCRIPTION
Rem      This procedure, view and temp table will allow you to see all
Rem      objects that are (recursively) dependent on the given object.
Rem      Note: you will only see objects for which you have permission.
Rem      Examples:
Rem        execute deptree_fill('procedure', 'scott', 'billing');
Rem        select * from deptree order by seq#;
Rem
Rem        execute deptree_fill('table', 'scott', 'emp');
Rem        select * from deptree order by seq#;
Rem
Rem        execute deptree_fill('package body', 'scott', 'accts_payable');
Rem        select * from deptree order by seq#;
Rem
Rem        A prettier way to display this information than
Rem		select * from deptree order by seq#;
Rem	   is
Rem             select * from ideptree;
Rem        This shows the dependency relationship via indenting.  Notice
Rem        that no order by clause is needed with ideptree.
Rem    RETURNS
Rem 
Rem    NOTES
Rem      Run this script once for each schema that needs this utility.
Rem      
Rem    MODIFIED   (MM/DD/YY)
Rem     rkooi      10/26/92 -  owner -> schema for SQL2 
Rem     glumpkin   10/20/92 -  Renamed from DEPTREE.SQL 
Rem     rkooi      09/02/92 -  change ORU errors 
Rem     rkooi      06/10/92 -  add rae errors 
Rem     rkooi      01/13/92 -  update for sys vs. regular user 
Rem     rkooi      01/10/92 -  fix ideptree 
Rem     rkooi      01/10/92 -  Better formatting, add ideptree view 
Rem     rkooi      12/02/91 -  deal with cursors 
Rem     rkooi      10/19/91 -  Creation 

drop sequence deptree_seq
/
create sequence deptree_seq cache 200 /* cache 200 to make sequence faster */
/
drop table deptree_temptab
/
create table deptree_temptab
(
  object_id            number,
  referenced_object_id number,
  nest_level           number,
  seq#                 number      
)
/
create or replace procedure deptree_fill (type char, schema char, name char) is
  obj_id number;
begin
  delete from deptree_temptab;
  commit;
  select object_id into obj_id from all_objects
    where owner        = upper(deptree_fill.schema)
    and   object_name  = upper(deptree_fill.name)
    and   object_type  = upper(deptree_fill.type);
  insert into deptree_temptab
    values(obj_id, 0, 0, 0);
  insert into deptree_temptab
    select object_id, referenced_object_id,
        level, deptree_seq.nextval
      from public_dependency
      connect by prior object_id = referenced_object_id
      start with referenced_object_id = deptree_fill.obj_id;
exception
  when no_data_found then
    raise_application_error(-20000, 'ORU-10013: ' ||
      type || ' ' || schema || '.' || name || ' was not found.');
end;
/

drop view deptree
/

set echo on

REM This view will succeed if current user is sys.  This view shows 
REM which shared cursors depend on the given object.  If the current
REM user is not sys, then this view get an error either about lack
REM of privileges or about the non-existence of table x$kglxs.

set echo off
create view sys.deptree
  (nested_level, type, schema, name, seq#)
as
  select d.nest_level, o.object_type, o.owner, o.object_name, d.seq#
  from deptree_temptab d, dba_objects o
  where d.object_id = o.object_id (+)
union all
  select d.nest_level+1, 'CURSOR', '<shared>', '"'||c.kglnaobj||'"', d.seq#+.5
  from deptree_temptab d, x$kgldp k, x$kglob g, obj$ o, user$ u, x$kglob c,
      x$kglxs a
    where d.object_id = o.obj#
    and   o.name = g.kglnaobj
    and   o.owner# = u.user#
    and   u.name = g.kglnaown
    and   g.kglhdadr = k.kglrfhdl
    and   k.kglhdadr = a.kglhdadr   /* make sure it is not a transitive */
    and   k.kgldepno = a.kglxsdep   /* reference, but a direct one */
    and   k.kglhdadr = c.kglhdadr
    and   c.kglhdnsp = 0 /* a cursor */
/

set echo on

REM This view will succeed if current user is not sys.  This view
REM does *not* show which shared cursors depend on the given object.
REM If the current user is sys then this view will get an error 
REM indicating that the view already exists (since prior view create
REM will have succeeded).

set echo off
create view deptree
  (nested_level, type, schema, name, seq#)
as
  select d.nest_level, o.object_type, o.owner, o.object_name, d.seq#
  from deptree_temptab d, all_objects o
  where d.object_id = o.object_id (+)
/

drop view ideptree
/
create view ideptree (dependencies)
as
  select lpad(' ',3*(max(nested_level))) || max(nvl(type, '<no permission>')
    || ' ' || schema || decode(type, NULL, '', '.') || name)
  from deptree
  group by seq# /* So user can omit sort-by when selecting from ideptree */
/
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">EXECUTE deptree_fill('procedure', 'ruminat', 'add_employee');</code></pre><pre><code class="language-output">PL/SQL procedure successfully completed.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">SELECT * FROM ideptree;</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>DEPENDENCIES</th></tr></thead><tbody><tr><td>PROCEDURE RUMINAT.ADD_EMPLOYEE</td></tr></tbody></table></row><pre class="line-numbers undefined"><code class="language-plsql">EXECUTE deptree_fill('function', 'ruminat', 'valid_deptid');</code></pre><pre><code class="language-output">PL/SQL procedure successfully completed.
</code></pre><pre class="line-numbers undefined"><code class="language-plsql">SELECT * FROM ideptree;</code></pre><row class="aligment-center"><table class="table table-SQL table-bordered table-hover table-sm"><thead class="thead-dark"><tr><th>DEPENDENCIES</th></tr></thead><tbody><tr><td style="white-space: pre;">   PROCEDURE RUMINAT.ADD_EMPLOYEE</td></tr><tr><td>FUNCTION RUMINAT.VALID_DEPTID</td></tr></tbody></table></row><p>Процедура <code class="language-plsql">deptree_fill</code> использует следующие системные словари: <code class="language-plsql">ALL_OBJECTS</code>, <code class="language-plsql">PUBLIC_DEPENDENCY</code>.</p></div><div class="task" id="task-21-3"><p class="task-text" name="task-21-3"><b>Задание 3.</b> Динамически определите <code>INVALID</code> объекты:</p><ol><li>Создайте копию таблицы <code class='language-plsql'>Employees</code> и назовите её <code class='language-plsql'>Emps</code>.<pre class="line-numbers undefined"><code class="language-plsql">CREATE TABLE Emps AS SELECT * FROM Employees;</code></pre><pre><code class="language-output">Table created.</code></pre></li><li>Измените таблицу <code class='language-plsql'>Employees</code>. Добавьте в нее колонку <code class='language-plsql'>TotSal</code> с типом данных <code class='language-plsql'>NUMBER(9, 2)</code>.<pre class="line-numbers undefined"><code class="language-plsql">ALTER TABLE Employees ADD (TotSal NUMBER(9, 2));</code></pre><pre><code class="language-output">Table altered.</code></pre></li><li>Создайте и сохраните локально скрипт для отображения имени, типа и статуса всех <code>INVALID</code> объектов. Запустите его и посмотрите результат.<pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE
PROCEDURE displayInvalidObjects IS
  counter SIMPLE_INTEGER := 0;
BEGIN
  DBMS_OUTPUT.PUT_LINE('INVALID objects:');
  FOR queryRow IN (
    SELECT *
    FROM USER_OBJECTS
    WHERE Status = 'INVALID'
    ORDER BY Object_Type
  ) LOOP
    counter := counter + 1;
    DBMS_OUTPUT.PUT_LINE(
        ' - '|| queryRow.Object_Type
      ||': ' || queryRow.Object_Name ||' is '|| queryRow.Status
    );
  END LOOP;
  IF counter = 0 THEN
    DBMS_OUTPUT.PUT_LINE('none');      
  END IF;
END;
/

BEGIN
  displayInvalidObjects;
END;
/</code></pre><pre><code class="language-output">Procedure created.

INVALID objects:
- PACKAGE: EMP_PKG is INVALID
- PACKAGE BODY: EMP_PKG is INVALID
- PACKAGE BODY: EMP_ACTIONS is INVALID
- PROCEDURE: GET_EMPLOYEE is INVALID
- TRIGGER: UPD_MINSALARY_TRG is INVALID
- TRIGGER: DELETE_EMP_TRG is INVALID
- TRIGGER: EMPLOYEE_INITJOBS_TRG is INVALID
- VIEW: EMPLOYEES_VU is INVALID
- VIEW: DISTR_VIEW is INVALID
- VIEW: SALARY_VU is INVALID</code></pre></li><li>В пакет <code class='language-plsql'>compile_pkg</code> добавьте процедуру <code class='language-plsql'>recompile</code>, которая перекомпилирует все <code>INVALID</code> объекты схемы (с использованием Native Dynamic SQL).<pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE PACKAGE compile_pkg IS
  PROCEDURE make (objectName USER_SOURCE.Name%TYPE);
  PROCEDURE recompile;
END compile_pkg;
/</code></pre><pre><code class="language-output">Package created.</code></pre><pre class="line-numbers undefined"><code class="language-plsql">CREATE OR REPLACE PACKAGE BODY compile_pkg IS
 
  -- ... ... ...

  PROCEDURE recompile IS
      objectType USER_SOURCE.Type%TYPE;
      statement VARCHAR2(256);
    BEGIN
      FOR queryRow IN (
        SELECT *
        FROM USER_OBJECTS
        WHERE Status = 'INVALID'
      ) LOOP
        objectType := REGEXP_SUBSTR(queryRow.Object_Type, '\w+', 1, 1);
        statement  := 'ALTER '|| objectType ||' '|| queryRow.Object_Name;
        IF objectType = 'PACKAGE' THEN
          EXECUTE IMMEDIATE statement ||' COMPILE SPECIFICATION';    
          EXECUTE IMMEDIATE statement ||' COMPILE BODY';    
        ELSE
          EXECUTE IMMEDIATE statement ||' COMPILE';    
        END IF;
      END LOOP;
    END;

END compile_pkg;
/</code></pre><pre><code class="language-output">Package body created.</code></pre></li><li>Выполните процедуру <code class='language-plsql'>compile_pkg.recompile</code>.<pre class="line-numbers undefined"><code class="language-plsql">BEGIN
  compile_pkg.recompile;
END;
/</code></pre><pre><code class="language-output">PL/SQL procedure successfully completed.</code></pre></li><li>Выполните заново скрипт из пункта 3. Убедитесь, что объектов со статусом <code>INVALID</code> в схеме не осталось.<pre class="line-numbers undefined"><code class="language-plsql">BEGIN
  displayInvalidObjects;
END;
/</code></pre><pre><code class="language-output">INVALID objects:
none</code></pre></li></ol></div></div></div></div><script src="./../js/prism.js"></script><script src="./../js/setup.js"></script><script src="./../js/main.js"></script></body></html>