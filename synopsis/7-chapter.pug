extends _synopsis.pug


block head
  - var chap = chapters[6];
  
  title #{chap.number}. #{chap.title}

block content
  .header
    h2 #{chap.number}. #{chap.title}

  +section('Введение в триггеры')

  p <b>Триггер</b> — это PL/SQL блок, который хранится в базе данных и срабатывает (выполняется) в ответ на указанное событие.

  p Триггер может быть определён на таблицу, представление, схему (владельца схемы) или базу данных (всех пользователей).

  p Типы событий триггеров:
  ul
    li DML-команда (#[+pl('DELETE')], #[+pl('INSERT')] или #[+pl('UPDATE')]).
    li DDL-команды (#[+pl('CREATE')], #[+pl('ALTER')] или #[+pl('DROP')]).
    li Операции базы данных, такие как #[+pl('SERVERERROR')], #[+pl('LOGON')], #[+pl('LOGOFF')], #[+pl('STARTUP')] или #[+pl('SHUTDOWN')].

  p Пример создания триггера:

  +plsql.
    CREATE OR REPLACE TRIGGER check_salary_trg
    -- перед INSERT в Employees или UPDATE столбцов Salary или Job_ID
    BEFORE INSERT OR UPDATE OF Salary, Job_ID ON Employees
    FOR EACH ROW -- строковый триггер, для каждой строки (не для всей DML-команды)
    BEGIN
      -- NEW — объект типа строки Employees, хранит строку после DML-команды
      -- OLD — то же самое, но до DML-операции
      check_salary(:NEW.Job_ID, :NEW.Salary); -- вызов процедуры check_salary
    END;
    /

  +section('Типы триггеров')

  p Триггеры делятся на:
  ul
    li Триггеры базы данных. Срабатывают при возникновении DML, DDL или системного события в схеме или базе данных.
    li Триггеры приложений. Срабатывают при возникновении события в конкретном приложении.

  p Триггеры можно использовать для:
  ul
    li Безопасности.
    li Аудита.
    li Целостности данных.
    li Ссылочной целостности.
    li Репликации (копирования) таблиц.
    li Автоматического вычисления производных данных.
    li Ведения журнала событий.

  p Допустимые типы триггеров:
  ul
    li Простые DML триггеры (#[+pl('BEFORE')], #[+pl('AFTER')], #[+pl('INSTEAD OF')]).
    li Составные (compound) триггеры.
    li Не-DML триггеры (DDL-события, события базы данных).

  p Триггеры бывают:
  ul
    li Уровня команды (по умолчанию). Срабатывают один раз на событие триггера, даже тогда, когда не затронута ни одна из строк.
    li Строковыми. Нужно прописать #[+pl('FOR EACH ROW')], срабатывают один раз на каждую затронутую строку по событию триггера, не срабатывают, если событие не затронуло ни одной строки.

  +section('Использование условных предикатов')

  p Можно так же задавать условия для выполнения триггеров.

  +plsql.
    CREATE OR REPLACE TRIGGER check_salary_trg
    BEFORE INSERT OR UPDATE OF Salary, Job_ID ON Employees
    FOR EACH ROW
    /*
      проверяем, что мы действительно обновляем столбец Job_ID или Salary
      или же вставляем новую строку
      (без этого триггер сработает на UPDATE, даже если фактическое значение не изменилось).
    */
    WHEN (
         OLD.Job_ID IS NULL       OR OLD.Salary IS NULL
      OR OLD.Job_ID != NEW.Job_ID OR OLD.Salary != NEW.Salary
    )
    -- Заметим, что внутри WHEN пишем «OLD», а внутри BEGIN..END — «:OLD».
    BEGIN
      check_salary(:NEW.Job_ID, :NEW.Salary);
    END;
    /

  p О #[+pl('NEW')] и #[+pl('OLD')]:
  +sqlTable
    thead.thead-dark
      tr
        th DML-команда
        th #[+pl('OLD')]
        th #[+pl('NEW')]
    tbody
      tr
        td #[+pl('INSERT')]
        td #[+pl('NULL')]
        td введённое значение
      tr
        td #[+pl('UPDATE')]
        td значение до обновления
        td значение после обновления
      tr
        td #[+pl('DELETE')]
        td удаляемое значение
        td #[+pl('NULL')]

  p Краткое описание модели выполнения триггера:
  ol
    li Выполняются все #[+pl('BEFORE')] триггеры уровня команды.
    li Для каждой строки, затронутой триггером:
      ol  
        li Выполняются все строковые #[+pl('BEFORE')] триггеры
        li Выполняется DML-команда и проверка ограничений целостности.
        li Выполняются все строковые #[+pl('AFTER')] триггеры.
    li Выполняются все #[+pl('AFTER')] триггеры уровня команды.

  p У триггера есть 2 состояния: #[+pl('ENABLE')] и #[+pl('DISABLE')]. Синтаксис:
  +plsql.
    CREATE OR REPLACE TRIGGER triggerName
    BEFORE INSERT ON tableName FOR EACH ROW
    DISABLE -- создание выключенного триггера
    BEGIN
      -- код
    END;
    /

    -- триггер можно выключить/включить, например, так:
    ALTER TRIGGER triggerName DISABLE; -- выключаем
    ALTER TRIGGER triggerName ENABLE;  -- включаем

  +section('Тестирование триггеров')

  ul
    li Протестируйте каждую операцию с данными, вызывающую срабатывание триггера, а также операции с данными, не вызывающие триггеры.
    li В каждом случае протестируйте условие #[+pl('WHEN')].
    li Вызовите срабатывание триггера непосредственно из операции с основными данными, а также косвенно из процедуры.
    li Проверьте влияния триггера на другие триггеры.
    li Проверьте влияния других триггеров на данный триггер.

  p Информацию о триггерах можно посмотреть в словарях #[+pl('USER_OBJECTS')], #[+pl('USER/ALL/DBA_TRIGGERS')]. Синтаксис ошибок триггеров можно посмотреть в словаре #[+pl('USER_ERRORS')].

  +section('Составные (compound) триггеры')

  p <b>Составной (compound) триггер</b> — это один триггер на таблицу, позволяющий задать действия для каждой из следующих четырёх точек синхронизации:
  ol
    li Перед вызывающей командой.
    li Перед каждой строкой, на которую влияет вызывающая команда.
    li После каждой строки, на которую влияет вызывающая команда.
    li После вызывающей команды.

  p <b>Мутирующая таблица</b> — это:
    ul  
      li Таблица, которая изменяется с помощью команды #[+pl('UPDATE')], #[+pl('DELETE')] или #[+pl('INSERT')], или
      li Таблица, которая может быть обновлена под действием ограничения #[+pl('DELETE CASCADE')].

  p Составные триггеры можно использовать для:
  ul  
    li Программирования подхода, в котором вы хотите, чтобы действия, которые вы выполняете для разных точек синхронизации, могли совместно использовать общие данные.
    li Накопления строк, предназначенных для второй таблицы; так что вы можете периодически их вставлять.
    li Того, чтобы избежать ошибки мутирующей таблицы #[+pl('(ORA-04091)')], разрешив накопление строк, предназначенных для второй таблицы, а затем их массовую вставку.

  p Ограничения составных триггеров:
  ul  
    li Составной триггер должен быть DML-триггером и определяться на таблицу или представление.
    li Тело составного триггера должно быть блоком составного триггера, написанным на языке PL/SQL.
    li Тело составного триггера не может иметь блок Инициализации, поэтому оно не может содержать раздел Исключений.
    li Исключение, которое происходит в одном разделе, должно быть обработано в том же разделе. Он не может передать управление другому разделу.
    li #[+pl(':OLD')] и #[+pl(':NEW')] нельзя использовать в разделах Объявления, #[+pl('BEFORE STATEMENT')] и #[+pl('AFTER STATEMENT')].
    li Только раздел #[+pl('BEFORE EACH ROW')] может изменять значение #[+pl(':NEW')].
    li Порядок срабатывания составных триггеров не гарантируется, если вы не используете #[+pl('FOLLOWS')].

  p Ограничение триггеров на мутирующие таблицы:
  ul
    li Сессия, использующая вызывающий триггер оператор, не может изменять мутирующую таблицу или выполнять к ней запросы.
    li Это ограничение не позволяет триггеру видеть несогласованный набор данных.
    li Это ограничение применяется ко всем триггерам, использующим раздел #[+pl('FOR EACH ROW')].
    li Представления, изменённые в триггерах #[+pl('INSTEAD OF')], не считаются мутирующими.

  +section('Создание триггеров системных событий')

  p Триггеры #[+pl('LOGON')] и #[+pl('LOGOFF')]. Пример:
  +plsql.
    CREATE OR REPLACE TRIGGER logon_trig
    AFTER LOGON ON SCHEMA
    BEGIN
      INSERT INTO log_trig_table(user_id, log_date, action)
      VALUES (USER, SYSDATE, 'Logging on');
    END;
    /

    CREATE OR REPLACE TRIGGER logoff_trig
    BEFORE LOGOFF ON SCHEMA
    BEGIN
      INSERT INTO log_trig_table(user_id, log_date, action)
      VALUES (USER, SYSDATE, 'Logging off');
    END;
    /

  p Можно использовать команду #[+pl('CALL')] внутри триггера:
  +plsql.
    CREATE OR REPLACE PROCEDURE log_execution IS
    BEGIN
      DBMS_OUTPUT.PUT_LINE('log_exection: Employee Inserted');
    END;
    /
    CREATE OR REPLACE TRIGGER log_employee
    BEFORE INSERT ON EMPLOYEES
    CALL log_execution -- точка с запятой не требуется
    /
  
  p Преимущества триггеров на события базы данных:
  ul
    li Повышают безопасность данных:
      ul
        li Обеспечивают расширенные и сложные проверки безопасности.
        li Обеспечивают расширенный и комплексный аудит.
    li Повышают целостность данных:
      ul
        li Применение ограничений динамической целостности данных.
        li Применение сложных ограничений ссылочной целостности.
        li Гарантия того, что связанные операции выполняются вместе неявно.

  p Системные привилегии, необходимые для управления триггерами:
  ul
    li Привилегия #[+pl('CREATE/ALTER/DROP (ANY) TRIGGER')], которая позволяет создавать триггеры в любой схеме.
    li Привилегия #[+pl('ADMINISTER DATABASE TRIGGER')], которая позволяет создавать триггеры базы данных.
    li Привилегия #[+pl('EXECUTE')] (если триггер ссылается на объекты, которых нет в схеме).

  +section('Рекомендации по Разработке Триггеров')

  ul
    li Триггеры разрабатываются для:
      ul
        li Выполнения связанных действий.
        li Централизации глобальных операций.
    li Не нужно разрабатывать триггеры:
      ul
        li Если функциональность уже встроена в сервер Oracle.
        li Которые дублируют уже существующие триггеры.
    li Можно создавать хранимые процедуры и вызывать их в триггере, если PL/SQL код очень длинный.
    li Чрезмерное использование триггеров может привести к сложным взаимозависимостям, которые трудно поддерживать в больших приложениях.